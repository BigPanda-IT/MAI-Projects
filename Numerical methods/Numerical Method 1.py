# -*- coding: utf-8 -*-
"""Untitled33.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RdfjBELYacy_JrLqEeDMJxMhLZH5OPos
"""

import copy

def matrixmult(A, B):
    C = [[0.0 for col in range(len(B[0]))] for row in range(len(A))]
    for i in range(len(A)):
        for j in range(len(B[0])):
            for k in range(len(B)):
                C[i][j] += A[i][k]*B[k][j]
    return C

def pivot_matrix(M):
    m = len(M)
    MCopy = copy.deepcopy(M)

    id_mat = [[float(i==j) for i in range(m)] for j in range(m)]
    row_exchanges = 0

    for i in range(m):
        maxElem = abs(MCopy[i][i])
        maxRow = i
        for k in range(i+1, m):
            if(abs(MCopy[k][i]) > maxElem):
                maxElem = abs(MCopy[k][i])
                maxRow = k
        if i != maxRow:
            id_mat[i], id_mat[maxRow] = id_mat[maxRow], id_mat[i]
            MCopy[i], MCopy[maxRow] = MCopy[maxRow], MCopy[i]
            row_exchanges += 1

    return id_mat, row_exchanges

def lup_decomposition(A):

    n = len(A)

    L = [[0.0] * n for i in range(n)]
    U = [[0.0] * n for i in range(n)]


    P, rowExc = pivot_matrix(A)
    PA = matrixmult(P, A)

    for j in range(n):

        L[j][j] = 1.0


        for i in range(j+1):
            s = sum(L[i][k] * U[k][j] for k in range(i))
            U[i][j] = PA[i][j] - s

        for i in range(j, n):
            s = sum(L[i][k] * U[k][j] for k in range(j))
            L[i][j] = (PA[i][j] - s) / U[j][j]

    return (P, L, U, rowExc)

def lup_solve(P,L,U,B):
    n = len(P)

    Bt = matrixmult(P, [[i] for i in B])

    Y = [0.0 for i in range(n)]
    for i in range(n):
        Y[i] = Bt[i][0]/L[i][i]
        for k in range(i):
            Y[i] -= Y[k]*L[i][k]

    X = [0.0 for i in range(n)]
    for i in range(n-1,-1,-1):
        s = sum(X[k]*U[i][k] for k in range(i+1,n))
        X[i] = (Y[i] - s)/U[i][i]

    return X

def lup_invert(P,L,U):
    n = len(P)

    IA = [[float(i==j) for i in range(n)] for j in range(n)]
    for i in range(n) :
        b = [IA[i][k] for k in range(n)]
        IA[i] = lup_solve(P,L,U,b)
    for i in range(n):
        for j in range(i):
            IA[i][j],IA[j][i] = IA[j][i],IA[i][j]

    return IA

def lup_determinant(U, rowExc):
    n = len(U[0])

    det = U[0][0]
    for j in range(1,n):
        det *= U[j][j]

    det *= (-1)**rowExc

    return det

def matmult(a,b):
   zip_b = zip(*b)
   zip_b = list(zip_b)
   return [[sum(elem_a*elem_b for elem_a, elem_b in zip(row_a, col_b)) for col_b in zip_b] for row_a in a]

def main():
    print("Matrix A:")
    A = []
    A.append([int(j) for j in input().strip().split(" ")])
    for i in range(1,len(A[0])) :
        A.append([int(j) for j in input().strip().split(" ")])

    print("Vector b:")
    b = [int(j) for j in input().strip().split(" ")]

    P, L, U, rowExc = lup_decomposition(A)
    print("Matrix P:")
    for elem in P:
        print(elem)
    print("Matrix L:")
    for elem in L:
        print(elem)
    print("Matrix U:")
    for elem in U:
        print(elem)

    LU = matmult(L, U)
    print("Matrix L*U")
    for elem in LU:
        print(elem)

    x = lup_solve(P,L,U,b)
    print("X:")
    print(x)

    IA = lup_invert(P,L,U)
    print("Inverted A:")

    for elem in IA:
        print(elem)

    AAIA = matmult(A, IA)
    print("Matrix A*IA")
    for elem in AAIA:
        print(elem)

    detA = lup_determinant(U, rowExc)
    print("Determinant of A: %d" % detA)

if __name__ == '__main__':
    main()

def progon(a, b, c, d):
    l = len(a)
    P, Q, X = [], [], [0]*l

    P.append(-c[0] / b[0])
    Q.append(d[0] / b[0])

    for i in range(1, l):

        if i == l - 1:
            p = 0
        else:
            p = - c[i] / (b[i] + a[i] * P[i-1])
        q = (d[i] - a[i] * Q[i-1]) / (b[i] + a[i] * P[i-1])

        P.append(p)
        Q.append(q)

    X[l-1] = Q[l-1]

    for i in range(l - 2, -1, -1):
        X[i] = P[i] * X[i+1] + Q[i]

    return X

print("Введите коэффициенты А:")
A = [0] + list(map(int, input().split()))

print("Введите коэффициенты В:")
B = list(map(int, input().split()))

print("Введите коэффициенты С:")
C = list(map(int, input().split())) + [0]

print("Введите правую часть:")
D = list(map(int, input().split()))

otvet = progon(A, B, C, D)

print("\nОтвет:")
if len(otvet) != 1:
    for i in range(len(otvet)):
        print("x{0} = {1}".format(i+1, otvet[i]))
else:
    print(otvet[0])

import sys

def check_iter(A):
   n = len(A[0])
   for i in range(n):
      suma = sum(abs(x) for x in A[i]) - abs(A[i][i])
      if abs(A[i][i])<= suma:
         return False
   return True

def simiter(A,b, eps):
   n = len(b)
   x = [0,0]
   x[0] = [b[i] * 1.0 / A[i][i] for i in range(n)]
   x[1] = [0 for _ in range(n)]
   alnorm = max(sum(abs(1.0*A[j][k]/A[j][j]) for k in range(n) if k != j) for j in range(n))
   coef = (alnorm/(1-alnorm)) if alnorm < 1 else 1
   it = 0
   while True:
      it += 1
      for j in range(n):
         x[it%2][j] = (b[j] - sum(A[j][k]*x[(it+1)%2][k] for k in range(n) if k != j)) * 1.0 / A[j][j]
      normx = coef * sum(abs(x[it%2][k]-x[(it+1)%2][k]) for k in range(n))
      if normx <= eps:
         return x[it%2], it

def main():
   print("Matrix A:")
   A = []
   A.append([int(j) for j in input().strip().split(" ")])
   for i in range(1,len(A[0])) :
      A.append([int(j) for j in input().strip().split(" ")])

   print("Vector b:")
   b = [int(j) for j in input().strip().split(" ")]

   if not(check_iter(A)):
      print("Not applicable")
      return

   print("Epsilon:")
   eps = float(input())

   x, it = simiter(A,b,eps)
   print("X:")
   print(x)
   print("Number of iterations:")
   print(it)

if __name__ == '__main__':
      main()

import sys

def check_iter(A):
   n = len(A[0])
   for i in range(n):
      suma = sum(abs(x) for x in A[i]) - abs(A[i][i])
      if abs(A[i][i])<= suma:
         return False
   return True

def seidel(A,b, eps):
   n = len(b)
   x = [0,0]
   x[0] = [b[i] * 1.0 / A[i][i] for i in range(n)]
   x[1] = [0 for _ in range(n)]
   alnorm = max(sum(abs(1.0*A[j][k]/A[j][j]) for k in range(n) if k != j) for j in range(n))
   cnorm = max(sum(abs(1.0*A[j][k]/A[j][j]) for k in range(j+1,n)) for j in range(n))
   coef = (cnorm/(1-alnorm)) if alnorm < 1 else 1
   it = 0
   while True:
      it += 1
      for j in range(n):
         x[it%2][j] = (b[j] - sum(A[j][k]*x[it%2][k] for k in range(j)) - sum(A[j][k]*x[(it+1)%2][k] for k in range(j+1,n))) * 1.0 / A[j][j]
      normx = coef * sum(abs(x[it%2][k]-x[(it+1)%2][k]) for k in range(n))
      if normx <= eps:
         return x[it%2], it

def main():
   print("Matrix A:")
   A = []
   A.append([int(j) for j in input().strip().split(" ")])
   for i in range(1,len(A[0])) :
      A.append([int(j) for j in input().strip().split(" ")])

   print("Vector b:")
   b = [int(j) for j in input().strip().split(" ")]

   if not(check_iter(A)):
      print("Seidel not applicable")
      return

   print("Epsilon:")
   eps = float(input())

   x, it = seidel(A,b,eps)
   print("X:")
   print(x)
   print("Number of iterations:")
   print(it)

if __name__ == '__main__':
    main()

import copy, math

def mult_matrix(A, B):
   C = [[0.0 for col in range(len(B[0]))] for row in range(len(A))]
   for i in range(len(A)):
      for j in range(len(B[0])):
         for k in range(len(B)):
            C[i][j] += A[i][k]*B[k][j]
   return C

def trans_matrix(M):
   n = len(M)
   return [[ M[i][j] for i in range(n)] for j in range(n)]

def check_symmetry(M):
   return M == trans_matrix(M)

def givens_rot(M, eps):
   n = len(M)
   A = copy.deepcopy(M)
   it = 0
   Ux = [[float(i == j) for j in range(n)] for i in range(n)]
   while True:
      it += 1
      a, i, j = 0.0, 0, 0
      for l in range(n):
         for m in range(l):
            if abs(A[l][m]) > a:
               a, i, j = abs(A[l][m]), l, m
      phi = 0.5 * (math.atan2(2*A[i][j], (A[i][i]-A[j][j]))) if A[i][i]-A[j][j] != 0 else math.pi / 4
      U = [[float(l == m) for m in range(n)] for l in range(n)]
      U[i][i] = math.cos(phi)
      U[j][j] = U[i][i]
      U[j][i] = math.sin(phi)
      U[i][j] = - U[j][i]
      A = mult_matrix(trans_matrix(U), mult_matrix(A, U))
      Ux = mult_matrix(Ux, U)
      t = math.sqrt(sum(sum(A[l][m]**2 for m in range(l)) for l in range(n)))
      if t <= eps :
         return [A[l][l] for l in range(n)], trans_matrix(Ux), it

def main():
   print("Matrix A:")
   A = []
   A.append([int(j) for j in input().strip().split(" ")])
   for i in range(1,len(A[0])) :
      A.append([int(j) for j in input().strip().split(" ")])

   if not(check_symmetry(A)):
      print("not solvable")
      return

   print("Epsilon:")
   eps = float(input())

   Lambdas, Ux, it = givens_rot(A,eps)
   print("Lambdas:")
   print(Lambdas)
   print("All X:")
   for elem in Ux:
      print(elem)
   print("Number of iterations:")
   print(it)

if __name__ == '__main__':
      main()

import copy, math, cmath

def mult_matrix(A, B):
   C = [[0.0 for col in range(len(B[0]))] for row in range(len(A))]
   for i in range(len(A)):
      for j in range(len(B[0])):
         for k in range(len(B)):
            C[i][j] += A[i][k]*B[k][j]
   return C

def trans_matrix(M):
   n = len(M)
   return [[ M[i][j] for i in range(n)] for j in range(n)]

def norm(x):
    return math.sqrt(sum([x_i**2 for x_i in x]))

def Q_i(Q_min, i, j, k):
    if i < k or j < k:
        return float(i == j)
    else:
        return Q_min[i-k][j-k]

def QR_decomp(A):
    n = len(A)

    R = copy.deepcopy(A)
    Q = [[0.0] * n for i in range(n)]

    for k in range(n-1):
        I = [[float(i == j) for i in range(n)] for j in range(n)]

        x = [row[k] for row in R[k:]]
        e = [row[k] for row in I[k:]]
        alpha = -((x[0] > 0) - (x[0] < 0))* norm(x)

        u = list(map(lambda p,q: p + alpha * q, x, e))
        norm_u = norm(u)
        v = list(map(lambda p: p/norm_u, u))

        Q_min = [ [float(i==j) - 2.0 * v[i] * v[j] for i in range(n-k)] for j in range(n-k) ]

        Q_t = [[ Q_i(Q_min,i,j,k) for i in range(n)] for j in range(n)]

        if k == 0:
            Q = Q_t
            R = mult_matrix(Q_t,A)
        else:
            Q = mult_matrix(Q_t,Q)
            R = mult_matrix(Q_t,R)

    return trans_matrix(Q), R

def QR_solve(A, eps):
   n = len(A)
   M = copy.deepcopy(A)
   it = 0
   while True:
      it += 1
      Q, R = QR_decomp(M)
      M = mult_matrix(R, Q)
      La = [M[l][l] for l in range(n)]
      t = True
      i = -1
      while i < n-2:
         i += 1
         if math.sqrt(sum(M[i][j]**2 for j in range(i+1, n))) > eps:
            if math.sqrt(sum(M[i][j]**2 for j in range(i+2, n))) <= eps:
               a = 1
               b = -(M[i][i]+M[i+1][i+1])
               c = M[i][i]*M[i+1][i+1] - M[i][i+1]*M[i+1][i]
               disc = b**2 - 4 * a * c
               l1 = (-b + cmath.sqrt(disc))/ (2 * a)
               l2 = (-b - cmath.sqrt(disc))/ (2 * a)
               La[i] = l1
               La[i+1] = l2
               i += 1
            else:
               t = False
               break
      if t:
         return La, it

def main():
   print("Matrix A:")
   A = []
   A.append([int(j) for j in input().strip().split(" ")])
   for i in range(1,len(A[0])) :
      A.append([int(j) for j in input().strip().split(" ")])

   print("Epsilon:")
   eps = float(input())

   Lambdas, it = QR_solve(A,eps)
   print("Lambdas:")
   print(Lambdas)
   print("Number of iterations:")
   print(it)

if __name__ == '__main__':
      main()