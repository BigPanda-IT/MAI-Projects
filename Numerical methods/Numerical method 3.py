# -*- coding: utf-8 -*-
"""Untitled30.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MeSbUz0NN_q8S2tlR9sp6DxvC2Iyv71h
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def f(x):
    return np.arccos(x)

def omega(x, X):
    w = 1
    for i in range(len(X)):
        w *= (x - X[i])
    return w

def L(x, X):
    l = 0.0
    for i in range(len(X)):
        l += (f(X[i]) * omega(x, X)) / ((x - X[i]) * omega(X[i], X))
    return l

def X_new(i, k, X):
    return [X[j] for j in range(i, k)]

def separate(X):
    if len(X) == 2:
        return (f(X[0]) - f(X[1])) / (X[0] - X[1])
    else:
        return (separate(X_new(0, len(X) - 1, X)) - separate(X_new(1, len(X), X))) / (X[0] - X[len(X) - 1])

def xxx(x, i, X):
    res = 1
    for j in range(i):
        res *= (x - X[j])
    return res

def P(x, X):
    p = f(X[0])
    for i in range(1, len(X)):
        X_ = X_new(0, i + 1, X)
        p += xxx(x, i, X) * separate(X_)
    return p

def main():
    X_a = np.array([-0.4, -0.1, 0.5, 0.8])
    X_b = np.array([-0.4, 0.0, 0.3, 0.5])
    X = 0.1
    Yi = np.array([])
    print("Выберите входные данные (a или b):")
    while True:
        bl = input()
        if bl == "a":
            print("a) Xi = [-0.4, -0.1, 0.2, 0.5]")
            print("Xi = ", X_a)
            for i in range(0, 4):
                 Yi = np.append(Yi, f(X_a[i]))
            print("Yi = ", Yi)
            print("\nМногочлен Лагранжа:")
            print("f(x*) = ", f(X))
            print("L(x*) = ", L(X, X_a))
            print("Абсолютная погрешность delta = ", f(X) - L(X, X_a))
            print("\nМногочлен Ньютона")
            print("f(x*) = ", f(X))
            print("P(x*) = ", P(X, X_a))
            print("Абсолютная погрешность delta = ", f(X) - P(X, X_a))
            # ГРАФИК ФУНКЦИИ
            xmin = -0.5
            xmax = 0.5
            dx = 0.01

            xarr = np.arange(xmin, xmax, dx)
            ylist = [f(x) for x in xarr]
            y_X_a = [f(x) for x in X_a]
            Larr = X_a
            Llist = [L(x + 0.1, X_a) for x in Larr]
            Parr = X_a
            Plist = [P(x, X_a) for x in Parr]
            fig = plt.figure(figsize=(8, 6))
            grid = plt.grid(True)
            plt.title('f(x)')
            plt.plot(xarr, ylist)
            plt.plot(Larr, Llist)
            plt.plot(Parr, Plist)
            plt.plot(X_a, y_X_a, '*')
            plt.xlabel('X')
            plt.ylabel('Y')
            plt.legend(['f(x)', 'L(x)', 'P(x)', 'Xa', 'Ox', 'Oy'])
            plt.show()
            break;
        elif bl == "b":
            print("b) Xi = [-0.4, 0.0, 0.2, 0.5]")
            print("Xi = ", X_b)
            for i in range(0, 4):
                Yi = np.append(Yi, f(X_b[i]))
            print("Yi = ", Yi)
            print("\nМногочлен Лагранжа:")
            print("f(x*) = ", f(X))
            print("L(x*) = ", L(X, X_b))
            print("Абсолютная погрешность delta = ", f(X) - L(X, X_b))
            print("\nМногочлен Ньютона")
            print("f(x*) = ", f(X))
            print("P(x*) = ", P(X, X_b))
            print("Абсолютная погрешность delta = ", f(X) - P(X, X_b))

            xmin = -0.5
            xmax = 0.5
            dx = 0.01
            xarr = np.arange(xmin, xmax, dx)
            ylist = [f(x) for x in xarr]
            y_X_b = [f(x) for x in X_b]
            Larr = X_b
            Llist = [L(x + 0.1, X_b) for x in Larr]
            Parr = X_b
            Plist = [P(x, X_b) for x in Parr]
            fig = plt.figure(figsize=(8, 6))
            grid = plt.grid(True)

            plt.title('f(x)')
            plt.plot(xarr, ylist)
            plt.plot(Larr, Llist)
            plt.plot(Parr, Plist)
            plt.plot(X_b, y_X_b, '*')
            plt.xlabel('X')
            plt.ylabel('Y')
            plt.legend(['f(x)', 'L(x)', 'P(x)', 'Xb', 'Ox', 'Oy'])
            plt.show()
            break;
        else:
            print("error")
            break;

if __name__ == '__main__':
    main()

import numpy as np
import matplotlib.pyplot as plt

def Lab3_2(a, b):
    p = np.zeros(len(b))
    q = np.zeros(len(b))

    p[0] = -a[0][1]/a[0][0]
    q[0] = b[0]/a[0][0]

    for i in range(1, len(p)-1):
        p[i] = -a[i][i+1]/(a[i][i] + a[i][i-1]*p[i-1])
        q[i] = (b[i] - a[i][i-1]*q[i-1])/(a[i][i] + a[i][i-1]*p[i-1])

    i = len(a)-1
    p[-1] = 0
    q[-1] = (b[-1] - a[-1][-2]*q[-2])/(a[-1][-1] + a[-1][-2]*p[-2])

    x = np.zeros(len(b))
    x[-1] = q[-1]
    for i in reversed(range(len(b)-1)):
        x[i] = p[i]*x[i+1] + q[i]
    return x

def S(x, X, F, bl):

    h = np.array([])
    n = len(X)
    for i in range(1, n):
        h = np.append(h, X[i] - X[i - 1])

    c_syst = np.array([])
    rows = np.array([])

    for i in range(n - 2):
        if i == 0:
            rows = np.append(rows, 2 * (h[i] + h[i + 1]))
        elif i == 1:
            rows = np.append(rows, h[i+1])
        else:
            rows = np.append(rows, 0)

    c_syst = np.append(c_syst, rows)

    for i in range(1, n - 3):
        rows = np.array([])
        for j in range(n - 2):
            if i - 1 == j:
                rows = np.append(rows, h[i-1])
            elif i == j:
                rows = np.append(rows, 2 * (h[i - 1] + h[i]))
            elif i + 1 == j:
                rows = np.append(rows, h[i])
            else:
                rows = np.append(rows, 0)
        c_syst = np.append(c_syst, rows)

    rows = np.array([])

    for i in range(2, n):
        if i == n - 2:
            rows = np.append(rows, h[i])
        elif i == n - 1:
            rows = np.append(rows, 2 * (h[i - 2] + h[i - 1]))
        else:
            rows = np.append(rows, 0)

    c_syst = np.append(c_syst, rows)

    b = np.array([])

    for i in range(2, n):
        b = np.append(b, 3 * ((F[i] - F[i - 1]) / h[i - 1] - (F[i - 1] - F[i - 2]) / h[i - 2]))
    c_matrix = np.zeros((3, 3))
    k = 0
    for i in range(3):
        for j in range(3):
            c_matrix[i][j] = c_syst[k]
            k += 1
    c = np.array([])
    c = np.append(c, 0)
    c = np.append(c, Lab3_2(c_matrix, b))

    a = np.array([])
    b = np.array([])
    d = np.array([])

    for i in range(n - 1):
        a = np.append(a, F[i])
        if i == n - 2:
            b = np.append(b, (F[i + 1] - F[i]) / h[i] - (2 / 3) * h[i] * c[i])
            d = np.append(d, - c[i] / (3 * h[i]))
        else:
            b = np.append(b, (F[i + 1] - F[i]) / h[i] - (1 / 3) * h[i] * (c[i + 1] + 2 * c[i]))
            d = np.append(d, (c[i + 1] - c[i]) / (3 * h[i]))

    if bl == 1:
        print("\nКоэффициенты сплайнов:")
        print("a = ", a)
        print("b = ", b)
        print("c = ", c)
        print("d = ", d)

    for i in range(n - 1):
        if (x >= X[i]) & (x <= X[i + 1]):
            res = a[i] + b[i] * (x - X[i]) + c[i] * (x - X[i]) ** 2 + d[i] * (x - X[i]) ** 3
            break

    return res

def main():
    x = 0.1
    X = np.array([ -0.4, -0.1, 0.2, 0.5, 0.8])
    F = np.array([1.9823, 1.6710, 1.3694, 1.0472, 0.64350])
    print('f(x*) = ', S(x, X, F, 1))

    xmin = -0.4
    xmax = 0.5
    dx = 0.001
    xarr = np.arange(xmin, xmax, dx)
    ylist = [S(x_, X, F, 0) for x_ in xarr]
    fig = plt.figure(figsize=(6, 4))
    grid = plt.grid(True)
    plt.title('S(x)')
    plt.plot(xarr, ylist)
    plt.plot(X, F, '*')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend(['S(x)', 'Xi'])
    plt.show()
main()

import copy, math, cmath
import matplotlib.pyplot as plt
import numpy as np

def matrixmult(A, B):
    C = [[0.0 for col in range(len(B[0]))] for row in range(len(A))]
    for i in range(len(A)):
        for j in range(len(B[0])):
            for k in range(len(B)):
                C[i][j] += A[i][k]*B[k][j]
    return C

def pivot_matrix(M):
    m = len(M)
    MCopy = copy.deepcopy(M)
    id_mat = [[float(i==j) for i in range(m)] for j in range(m)]
    row_exchanges = 0
    for i in range(m):
        maxElem = abs(MCopy[i][i])
        maxRow = i
        for k in range(i+1, m):
            if(abs(MCopy[k][i]) > maxElem):
                maxElem = abs(MCopy[k][i])
                maxRow = k
        if i != maxRow:
            id_mat[i], id_mat[maxRow] = id_mat[maxRow], id_mat[i]
            MCopy[i], MCopy[maxRow] = MCopy[maxRow], MCopy[i]
            row_exchanges += 1

    return id_mat, row_exchanges

def lup_decomposition(A):
    n = len(A)
    L = [[0.0] * n for i in range(n)]
    U = [[0.0] * n for i in range(n)]
    P, rowExc = pivot_matrix(A)
    PA = matrixmult(P, A)

    for j in range(n):
        L[j][j] = 1.0

        for i in range(j+1):
            s = sum(L[i][k] * U[k][j] for k in range(i))
            U[i][j] = PA[i][j] - s

        for i in range(j, n):
            s = sum(L[i][k] * U[k][j] for k in range(j))
            L[i][j] = (PA[i][j] - s) / U[j][j]

    return (P, L, U, rowExc)

def lup_solve(P,L,U,B):
    n = len(P)
    Bt = matrixmult(P, [[i] for i in B])
    Y = [0.0 for i in range(n)]

    for i in range(n):
        Y[i] = Bt[i][0]/L[i][i]
        for k in range(i):
            Y[i] -= Y[k]*L[i][k]

    X = [0.0 for i in range(n)]

    for i in range(n-1,-1,-1):
        s = sum(X[k]*U[i][k] for k in range(i+1,n))
        X[i] = (Y[i] - s)/U[i][i]

    return X

def lsm1(x,y):
    n = len(x)
    A = [[n, sum(x)],
         [sum(x), sum(el**2 for el in x)]]
    P, L, U, _ = lup_decomposition(A)
    ynew = [sum(y),sum(x[i]*y[i] for i in range(n))]
    a = lup_solve(P,L,U,ynew)

    return lambda x: a[0] + a[1]*x

def main():

    x = [-0.7, -0.4, -0.1, 0.2, 0.5, 0.8]
    y = [2.3462, 1.9823, 1.671, 1.3694, 1.0472, 0.6435]

    func = lsm1(x,y)
    xnew = np.linspace(min(x),max(x),100)
    ynew = [func(el) for el in xnew]
    print(x)
    print(y)
    print(xnew)
    print(ynew)
    print("\nГрафик:")
    plt.plot(x,y,'o',xnew,ynew)
    plt.grid(True)
    plt.show()
    print("\nВывод суммы квадратов ошибок:")
    print(sum((func(x[i])-y[i])**2 for i in range(len(x))))

if __name__ == '__main__':
      main()

def lup_decomposition(A):
    n = len(A)
    L = [[0.0] * n for i in range(n)]
    U = [[0.0] * n for i in range(n)]

    P, rowExc = pivot_matrix(A)
    PA = matrixmult(P, A)

    for j in range(n):
        L[j][j] = 1.0
        for i in range(j+1):
            s = sum(L[i][k] * U[k][j] for k in range(i))
            U[i][j] = PA[i][j] - s

        for i in range(j, n):
            s = sum(L[i][k] * U[k][j] for k in range(j))
            L[i][j] = (PA[i][j] - s) / U[j][j]

    return (P, L, U, rowExc)

def lup_solve(P,L,U,B):
    n = len(P)
    Bt = matrixmult(P, [[i] for i in B])
    Y = [0.0 for i in range(n)]

    for i in range(n):
        Y[i] = Bt[i][0]/L[i][i]
        for k in range(i):
            Y[i] -= Y[k]*L[i][k]

    X = [0.0 for i in range(n)]

    for i in range(n-1,-1,-1):
        s = sum(X[k]*U[i][k] for k in range(i+1,n))
        X[i] = (Y[i] - s)/U[i][i]

    return X

def lsm2(x,y):
    n = len(x)
    A = [[n, sum(x), sum(el**2 for el in x)],
         [sum(x), sum(el**2 for el in x), sum(el**3 for el in x)],
         [sum(el**2 for el in x), sum(el**3 for el in x), sum(el**4 for el in x)]]
    P, L, U, _ = lup_decomposition(A)
    ynew = [sum(y),sum(x[i]*y[i] for i in range(n)),sum(y[i]*x[i]**2 for i in range(n))]
    a = lup_solve(P,L,U,ynew)

    return lambda x: a[0] + a[1]*x + a[2]*x**2

def main():

    x = [-0.7, -0.4, -0.1, 0.2, 0.5, 0.8]
    y = [2.3462, 1.9823, 1.671, 1.3694, 1.0472, 0.6435]

    func = lsm2(x,y)
    xnew = np.linspace(min(x),max(x),100)
    ynew = [func(el) for el in xnew]
    print(x)
    print(y)
    print(xnew)
    print(ynew)
    print("\nГрафик:")
    plt.plot(x,y,'o',xnew,ynew)
    plt.grid(True)
    plt.show()
    print("\nВывод суммы квадратов ошибок:")
    print(sum((func(x[i])-y[i])**2 for i in range(len(x))))

if __name__ == '__main__':
      main()

def main():

    X = [-1.0, 0.0, 1.0, 2.0, 3.0]
    Y = [2.3562, 1.5708, 0.7854, 0.46365, 0.32175]
    Xp = 1.0

    Yd = (Y[2] - Y[1])/(X[2]-X[1])
    print("The left-hand derivative 1:")
    print(Yd)

    Yd = (Y[3] - Y[2])/(X[3]-X[2])
    print("The right-hand derivative 1:")
    print(Yd)

    Yd = (Y[2] - Y[1])/(X[2]-X[1]) + (((Y[3]-Y[2])/(X[3]-X[2])-(Y[2]-Y[1])/(X[2]-X[1]))/(X[3]-X[1]))*(2*Xp-X[1]-X[2])
    print("The first derivative:")
    print(Yd)

    Yd = 2*(((Y[3]-Y[2])/(X[3]-X[2])-(Y[2]-Y[1])/(X[2]-X[1]))/(X[3]-X[1]))
    print("The second derivative:")
    print(Yd)

if __name__ == '__main__':
      main()

import numpy as np

def y(x):
    return x/(x**2+9)

def rectangle(x0, xk, f, h):
    X = np.arange(x0, xk, h)
    return h * sum([f(X[i] + h / 2) for i in range(len(X))])  # метод прямоугольников

def trapeze(x0, xk, f, h):
    X = np.arange(x0, xk, h)
    return h * ((f(X[0]) + f(xk)) / 2 + sum([f(X[i]) for i in range(1, len(X))]))   # метод трапеций

def Simpson(x0, xk, f, h):
    res = 0
    x = x0 + h
    while x < xk:
        res += f(x - h) + 4 * f(x) + f(x + h)
        x += 2 * h
    return (h / 3) * res    # метод Симпсона

def RR(F1, F2, h1, h2, p):
    if h1 < h2:
        return F1 + (F1 - F2) / ((h2 / h1) ** p - 1)
    return F2 + (F2 - F1) / ((h1 / h2) ** p - 1)       # метод Рунге-Ромберга

def main():

    x0 = 0; xk = 2; h1 = 0.5; h2 = 0.25
    p = 2
    p1 = rectangle(x0, xk, y, h1)
    t1 = trapeze(x0, xk, y, h1)
    s1 = Simpson(x0, xk, y, h1)
    p2 = rectangle(x0, xk, y, h2)
    t2 = trapeze(x0, xk, y, h2)
    s2 = Simpson(x0, xk, y, h2)
    rp = RR(p1, p2, h1, h2, p)
    rt = RR(t1, t2, h1, h2, p)
    rs = RR(s1, s2, h1, h2, 4)

    print("Начальные данные:\nX0 = 0, Xk = 2, h1 = 0.5, h2 = 0.25\n")
    print('Для h1 = {}:'.format(h1))
    print("Метод прямоугольников: {}".format(p1))
    print("Метод трапеций: {}".format(t1))
    print("Метод Симпсона: {}".format(s1))

    print('\nДля h2 = {}:'.format(h2))
    print("Метод прямоугольников: {}".format(p2))
    print("Метод трапеций: {}".format(t2))
    print("Метод Симпсона: {}".format(s2))

    print("\nЗначение по методу Рунге-Ромбергу для прямоугольника:", rp)
    print("Погрешность: {0} и {1}".format(abs(rp - p1), abs(rp - p2)))
    print("\nЗначение по методу Рунге-Ромбергу для трапеции:", rt)
    print("Погрешность: {0} и {1}".format(abs(rt - t1), abs(rt - t2)))
    print("\nЗначение по методу Рунге-Ромбергу для Симпсона:", rs)
    print("Погрешность: {0} и {1}".format(abs(rs - s1), abs(rs - s2)))

if __name__ == '__main__':
      main()